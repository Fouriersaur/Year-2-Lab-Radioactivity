import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.optimize import curve_fit
from scipy.stats import chi2

# ======= Time interval per measurement bin (seconds) =======
dt = 1.0

# ======= Folder and files =======
folder = "/Users/edwinko/Year-2-Lab-Radioactivity/100Second_Source_2_Session_3"

files = [
    "task15_St_2cm_100cycles_s3.txt",
    "task15_St_3cm_100cycles_s3.txt",
    "task15_St_5cm_100cycles_s3.txt",
    "task15_St_7cm_100cycles_s3.txt",
    "task15_St_10cm_100cycles_s3.txt",
    "task15_St_15cm_100cycles_s3.txt",
    "task15_St_20cm_100cycles_s3.txt",
    "task15_St_30cm_100cycles_s3.txt",
    "task15_St_40cm_100cycles_s3.txt",
    "task15_St_50cm_100cycles_s3.txt",
    "task15_St_60cm_100cycles_s3.txt",
    "task15_St_69cm_100cycles_s3_2.txt",
    "task15_St_80cm_100cycles_s3.txt",
    "task15_St_90cm_100cycles_s3.txt"
]

# distances in meters
distances = np.array([2,3,5,7,10,15,20,30,40,50,60,69,80,90]) * 0.01

# ======= Error function =======
def calc_error(counts, distance, dt):
    sigma_d = 0.001
    n = np.sum(counts)
    delta_t = len(counts) * dt
    return np.sqrt(n*distance**4 + 4*n**2*distance**2*sigma_d**2) / delta_t

# ======= Load data =======
scaled_values = []
errors = []
valid_dist = []

for f, d in zip(files, distances):
    path = os.path.join(folder, f)
    if not os.path.exists(path):
        print(f"Missing file: {f}")
        continue
    counts = np.loadtxt(path)
    n = np.sum(counts)
    delta_t = len(counts) * dt
    Q = n * d**2 / delta_t
    scaled_values.append(Q)
    errors.append(calc_error(counts, d, dt))
    valid_dist.append(d)

scaled_values = np.array(scaled_values)
errors = np.array(errors)
valid_dist = np.array(valid_dist)

# ======= Combined model (geometry × attenuation) =======
def Q_combined(d, A, a, mu):
    return A * d**2 * (1 - d/np.sqrt(d**2 + a**2)) * np.exp(-mu*d)

# ======= Fit combined model =======
p0 = [np.mean(scaled_values), 0.01, 0.01]
popt_comb, pcov_comb = curve_fit(
    Q_combined, valid_dist, scaled_values, sigma=errors, absolute_sigma=True, p0=p0, maxfev=10000
)
A_fit, a_fit, mu_fit = popt_comb

# ======= Horizontal (constant) model =======
def Q_constant(d, C):
    return C

popt_const, _ = curve_fit(
    Q_constant, valid_dist, scaled_values, sigma=errors, absolute_sigma=True
)
C_fit = popt_const[0]

# ======= Compute chi-squared and p-values =======
# Combined model
res_comb = (scaled_values - Q_combined(valid_dist, *popt_comb)) / errors
chi2_comb = np.sum(res_comb**2)
dof_comb = len(valid_dist) - len(popt_comb)
p_comb = 1 - chi2.cdf(chi2_comb, dof_comb)

# Constant model
res_const = (scaled_values - Q_constant(valid_dist, C_fit)) / errors
chi2_const = np.sum(res_const**2)
dof_const = len(valid_dist) - 1
p_const = 1 - chi2.cdf(chi2_const, dof_const)

print("===== Fit Comparison =====")
print(f"Combined model: χ² = {chi2_comb:.2f}, dof = {dof_comb}, p = {p_comb:.4f}")
print(f"Constant model: χ² = {chi2_const:.2f}, dof = {dof_const}, p = {p_const:.4f}")

# ======= Plot =======
d_fit = np.linspace(min(valid_dist), max(valid_dist), 500)
plt.figure(figsize=(8,6))
plt.errorbar(valid_dist, scaled_values, yerr=errors, fmt='o', capsize=6, elinewidth=1.5, label="Data")
plt.plot(d_fit, Q_combined(d_fit, *popt_comb), 'r-', label="Combined model fit")
plt.plot(d_fit, np.full_like(d_fit, C_fit), 'g--', label="Horizontal fit")

plt.xlabel("Distance (m)")
plt.ylabel(r"$n d^2 / \Delta t$ (counts·m²/s)")
plt.title("Combined vs Horizontal Model Fit")
plt.legend()
plt.grid(False)
plt.ylim(0, np.max(scaled_values)*1.2)
plt.show()